#!/usr/bin/env python3
"""
Tasks
Get example output for tests - Ted
Parser for ODGI Bin file format - Ted
Component Segmentation Detection - Josiah and Joerg
  Python memory object model - Josiah
Output format
"""
from typing import List, Tuple, Set
from matrixcomponent.matrix import Path, PangenomeSchematic, Component
import os
import logging
import argparse
import matrixcomponent

import matrixcomponent.JSONparser as JSONparser

LOGGER = logging.getLogger(__name__)
"""logging.Logger: The logger for this module"""


def segment_matrix(matrix: List[Path]) -> PangenomeSchematic:
    print(f"Starting Segmentation process on {len(matrix)} Paths.")
    schematic = PangenomeSchematic([])
    beginnings, ends = find_dividers(matrix)
    for begin, end in zip(beginnings, ends):
        schematic.components.append(Component(begin, end))
    # populate all links onto schematic

    return schematic


def find_dividers(matrix: List[Path]) -> Tuple[Set[int], Set[int]]:
    max_bin = 13176+1 # TODO: find this
    ends = {max_bin}  # list of indices of new components
    beginnings = {0}  # list of indices of new components
    for path in matrix:
        print(f"Segmenting {len(path.bins)}")
        for link in path.links:  # Links are generated by odgi based
            upstream, downstream = link.upstream, link.downstream
            missing_range = list(range(upstream + 1, downstream))
            # Is the gap range anywhere else in this individual?
            # What if downstream < upstream?
            divider_verified = downstream < upstream
            if not divider_verified:
                for i in missing_range:
                    if i in path:
                        divider_verified = True
                        break  # stop as soon as we have confirmation
            if divider_verified:
                if (upstream + 1) in ends :
                    print("Found inherited rearrangement {upstream+1}")
                ends.add(upstream + 1)  # the first position of the new component
                beginnings.add(downstream)
                # TODO: insert prevarications about exact position
                # Divider should be somewhere in here
                # Tolerable range?
                # Stack up others using the same Link
    return beginnings, ends


def discard_useless_links(matrix: List[Path]):
    """https://github.com/vgteam/odgi/issues/48
    Links that simply span a gap in the matrix can be discarded"""
    for path in matrix:
        keep = []
        for link in path.links:  # Links are generated by odgi based
            missing_range = list(range(link.upstream + 1, link.downstream))
            # Is the gap range anywhere else in this individual?
            if any([i in path for i in missing_range if i > 0]):
                keep.append(link)
        path.links = keep  # all other Paths get deleted


def setup_logging(output_dir):
    """Setup the logging, add a log file"""
    log_name = os.path.join(output_dir, 'log')
    handler = logging.FileHandler(log_name)
    handler.setLevel(args.log_level)
    handler.setFormatter(logging.Formatter(matrixcomponent.LOGGING_FORMAT_STR,
                                           datefmt=matrixcomponent.LOGGING_DATE_FORMAT))
    logging.getLogger().addHandler(handler)


# Helper class to allow multi-line help messages for argparse user parameters:
class SmartFormatter(argparse.HelpFormatter):
    def _split_lines(self, text, width):
        if text.startswith('R|'):
            return text[2:].splitlines()
        # this is the RawTextHelpFormatter._split_lines
        return argparse.HelpFormatter._split_lines(self, text, width)


def get_arguments():
    """Create the command line interface and return the command line arguments

    Returns
    -------
    Namespace
        The command line arguments

    """
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description="")

    parser.add_argument('-j', '--json-file',
                            dest='json_file',
                            required=True,
                            help='input JSON file')

    parser.add_argument('-o', '--out-folder',
                        dest='output_folder',
                        required=True,
                        help='output folder')

    parser.add_argument('-l', '--log-level',
                        default='DEBUG',
                        choices=('DEBUG', 'INFO', 'WARNING', 'ERROR'),
                        help='level of logging verbosity. DEBUG is most verbose')

    args = parser.parse_args()

    return args

def main():
    global args
    args = get_arguments()
    setup_logging(args.output_folder)
    LOGGER.info("starting...\n")
    Paths = JSONparser.parse(args.json_file)
    schematic = segment_matrix(Paths)


if __name__ == '__main__':

    main()

